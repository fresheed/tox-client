\documentclass{/home/fresheed/utils/latex/university-templates/lab-report}
\setSourceBase{./}
\renewcommand{\picspath}{./}

\begin{document}
% Номер, тема, предмет, преподаватель

\begin{titlepage}
  \centering
  \large Санкт-Петербургский Политехнический университет Петра Великого\\
  \large Институт компьютерных наук и технологий \\
  \large Кафедра компьютерных систем и программных технологий\\

  % \vspace{3cm}
  \vfill

  % \Large Отчёт по лабораторной работе №NUMBER\_OPTIONAL \par
  \Large Отчёт по курсовой работе

  \vspace{0.5cm} 

  % \LARGE THEME
  \LARGE Реализация TCP-клиента для протокола Tox

  \vspace{0.5cm}

  \Large по предмету "Сети и телекоммуникации"

  \vspace{0.5cm} 

  \vfill
  \begin{flushright}
    Выполнил студент гр. 43501/3 \\
    Намаконов Егор \\
    Преподаватель \\
    % TEACHER \\
    Зозуля А.В. \\
  \end{flushright}
  \vfill

  % Bottom of the page
  \large \today\par
\end{titlepage}

\tableofcontents

\section{Назначение и особенности протокола}

Tox — открытый протокол для текстовой, голосовой и видеосвязи в интернете. Отличительная особенность - пoлная децентрализация и шифрование всего трафика. Эталонная реализация включает следующие функции:
\begin{itemize}
\item голосовая и видеосвязь
\item режим конференции с несколькими участниками
\item указание и смена сетевого статуса
\item поддержка эмотиконов
\item демонстрация экрана
\item возможность отправлять мгновенные сообщения и передавать файлы
\item и т.д.
\end{itemize}

Позиционируется как открытая, свободная, лишённая бэкдоров и не шпионящая за пользователями альтернатива Skype. Так как протокол является открытым, а узлы сети организуются всеми желающими, реклама отсутствует. 

Одна из особенностей протокола - 32-битные публичные ключи, которые генерируются локально у каждого участника и которые служат для идентификации во всей сети. После установки Tox автоматически создаётся пара ключей. Публичный ключ можно передавать кому угодно — он служит как уникальный идентификатор для поиска собеседника. Секретный ключ хранится только у владельца и подтверждает его подлинность не раскрывая персональные данные. Центральный сервер отсутствует, поиск собеседников происходит через DHT.

Криптографические функции выполняются с помощью библиотеки NaCl.


\section{Алгоритмы работы протокола}

\newcommand{\defn}[1]{
  \textbf{#1}
}

\subsection{Организация сети}

Сеть участников Tox образует т.н. \defn{DHT} - Distributed Hash Table. 
Хеш-таблица может представлять собой ассоциативный массив, содержащий пары (ключ-значение). Особенностью распределённой таблицы является возможность распределить информацию среди некоторого набора узлов-хранителей таким образом, что каждый участвующий узел смог бы найти значение, ассоциированное с данным ключом. Ответственность за поддержание связи между именем и значением распределяется между узлами, в силу чего изменение набора участников является причиной минимального количества разрывов. Это позволяет легко масштабировать DHT, а также постоянно отслеживать добавление и удаление узлов и ошибки в их работе.\footnote{https://en.wikipedia.org/wiki/Distributed\_hash\_table}

Хэш-таблица Tox содержит зашифрованные сетевые адреса участников, которые расшифровываются только на двух конечных узлах, которые желают установить соединение друг с другом. Таким образом, Tox предполагает, что сетевой адрес узла нельзя узнать, не установив соединение с ним. 

Для того, чтобы подключиться к сети, участник посылает запрос к одному из существующих узлов, запрашивает у него список других клиентов, к которым можно подключиться и продолжает этот процесс, расширяя список известных участников. Обычно для начала этого процесса необходим \defn{bootstrap-узел}. Это узел, к которому клиент подключается, если не знает других участников. Очевидно, что bootstrap-узлы должны работать стабильно и иметь известные адреса. Актуальный список bootstrap-узлов находится на https://nodes.tox.chat/.


\subsection{Соединение между узлами}

Для создания соединения между 2 узлами (\defn{friend connection}) используются \defn{friend requests}. Для его отправки необходимы \defn{Tox ID} участников, которые имеют следующую структуру:

\begin{enumerate}
\item 32 байта - публичный ключ
\item 4 байта - \defn{nospam} - дополнительный идентификатор, назначение которого - гарантировать, что friend request может отправить только тот, кто видел Tox ID целиком, а не только публичный ключ. Nospam можно сменить при необходимости
\item 2 байта - контрольная сумма, которая образуется XORом всех последовательных пар байт Tox ID ($0,1 \oplus 2,3 \oplus  4,5 ... \oplus  34,35$).
\end{enumerate}

После установления соединения узлы могут начать обмен сообщениями.


\subsection{TCP-соединения}

По умолчанию Tox использует UDP для обмена данными. Однако если участник находится в локальной сети за NAT, то такой трафик может быть заблокирован. Поэтому при работе из локальной сети участник должен пользоваться \defn{TCP relays}. Эти узлы позволяют подключаться к сети тем участникам, которые не могут общаться напрямую.

Такой сервер ведёт себя как посредник между двумя узлами. После подключения к серверу клиент указывает, к какому собеседнику он хочет подключиться. Соединение будет установлено только тогда, когда оба участника отправят такие запросы. Это позволяет избежать проверок на то, подключён ли тот или иной узел к сети.

\subsection{Процедура подключения к TCP-серверу}

Наиболее абстрактно последовательность действий представляется так:

\begin{enumerate}
\item Клиент, зная публичный ключ сервера, отправляет тому handshake-пакет
\item Сервер отвечает handshake-ответом
\item Клиент отправляет любой пакет протокола, чтобы сервер убедился в корректности установления соединения
\item Сервер обрабатывает соответствующий пакет (ответ на пинг и т.д.)
\end{enumerate}

Весь трафик при обмене шифруется. При этом ключи, которые в дальнейшем будут использоваться при обмене данными с сервером в рамках этого соединения, не равны постоянным ключам клиента и сервера - они генерируются на время соединения.

Handshake-запрос имеет следующую структуру:

\begin{enumerate}
\item 32 байта - постоянный публичный ключ клиента, который он анонсирует серверу и всей сети
\item 24 байта - временный т.н. \defn{nonce} - одноразовый код, который выбирается в данном пакете случайно и используется для шифрования-дешифрования сообщений вместе с ключом. В дальнейшем для его генерации будут использоваться различные алгоритмы
\item зашифрованный с помощью публичного ключа сервера, приватного ключа клиента и nonce фрагмент (длина в зашифрованном виде - 72 байта):
  \begin{enumerate}
  \item 32 байта - временный публичный ключ, который будет использоваться для шифрования данных, отправляемых клиенту
  \item 24 байта - базовый Nonce, который будет использоваться вместе с временным ключом для шифрования
  \end{enumerate}
\end{enumerate}

Handshake-ответ имеет следующую структуру:

\begin{enumerate}
\item 24 байта -  nonce
\item зашифрованный с помощью публичного ключа клиента, приватного ключа сервера и nonce фрагмент (длина в зашифрованном виде - 72 байта):
  \begin{enumerate}
  \item 32 байта - временный публичный ключ, который будет использоваться для шифрования данных, отправляемых серверу
  \item 24 байта - базовый Nonce, который будет использоваться вместе с временным ключом для шифрования
  \end{enumerate}
\end{enumerate}

Публичный ключ сервера в обмене не указывается, т.к. предполагается, что клиенту он известен вместе с сетевым адресом сервера.

Далее клиент должен отправить любой пакет протокола, чтобы сервер убедился в корректности установления соединения. Обычно отправляется ping-запрос, на который сервер даёт ping-ответ.

\subsection{Обмен данными с сервером}

После handshake шифрование производится симметричным алгоритмом с использованием секретного ключа. Он вычисляется на основе временных ключей данного соединения и одинаков для обеих сторон.

При этом nonce различается для каждого пакета, отправленного одной из сторон. Он вычисляется так: base nonce (отправленный в handshake соответствующей стороной), представленный как 24-битное беззнаковое целое + номер текущего сообщения в данном направлении (начиная с 0 и не считая handshake). Документация в данном случае не даёт чёткого объяснения, какой из nonce соответствует направлению обмена. Экспериментально установлено, что nonce устанавливает сторона, которая будет отправлять пакеты в данном направлении, т.е., например, клиент будет использовать base nonce, который он отправил в handshake request. 

Зашифрованные пакеты выглядят в TCP-потоке так:

\begin{enumerate}
\item 2 байта - длина зашифрованного сообщения
\item зашифрованное сообщение соответствующей длины (до 2048, согласно документации)
\end{enumerate}


\subsection{Установление соединения между клиентами посредством TCP-сервера}

При установлении соединения между клиентами из разных локальных сетей с помощью TCP-сервера происходит следущее:

\begin{enumerate}
\item клиенты подключаются к серверу
\item клиенты отправляют запросы на установление соединения друг с другом, используя публичные ключи. При этом сервер отправляет им номер подключения, который соответствует паре этих клиентов
\item после получения обоих запросов сервер отправляет клиентам уведомление о том, что данное подключение активно
\item после отключения одного из клиентов сервер уведомляет другого о деактивации соединения
\end{enumerate}

Пакет для установления соединения с другим клиентом - Routing Request и Response; уведомления о статусе соединения - Connect и Disconnect Notification. Эти пакеты имеют простую структуру и хорошо описаны в спецификации. Отметим лишь следующие моменты, относящиеся к Routing Response:
\begin{itemize}
\item в ответе дублируется публичный ключ целевого клиента, к которому производится попытка подключения. Это позволяет отправить сразу несколько запросов на подключение к разным клиентам и обработать ответы на них по отдельности
\item Единственная причина (на настоящий момент) не создать номер подключения - превышение максимального количества одновременных подключений к серверу. В этом случае вместо номера подключения отправляется 0
\end{itemize}

\subsection{Обмен данными между клиентами с использованием TCP-сервера}

Этот аспект в рамках курсовой работы 2017 года изучен не был. По-видимому, реализуется следующий алгоритм\footnote{https://habrahabr.ru/post/217289/}:

\begin{verbatim}
1) Алиса пользуется Tox на соединении которое допускает только TCP подключения,
она генерирует временные публичные ключи и подключается к узлам для инициализации.

2) После получения данных о сети с узлов инициализации, она выбирает некоторое
количество случайных узлов которые являются супер-нодами

3) Она, используя луковичный роутинг через TCP супер-ноду может отправлять запросы на
авторизацию или сообщить своему контакт-списку о своём он-лайн статусе, используя 
временный публичный ключ.

4) Боб получает пакет через луковичный роутинг от Алисы, которая сообщает ему,
к каким узлам она подключена по DHT с использованием временного публичного ключа.

5) Боб подключается к тем же узлам что и Алиса.

6) Данное соединение используется для передачи как сообщений так и A/V трафика

7) Если какой-либо узел отключается, Боб и Алиса переходят на любой другой узел, 
к которому они оба подключены.

Супер нода — это такой узел, у которого имеется внешний IP адрес и проброшены порты Tox. 
\end{verbatim}

В приведённой ниже реализации клиента обмен производится с помощью \defn{OOB}-пакетов (Out Of Band). Их можно рассматривать как технические пакеты, которые отправляются по указанному публичному ключу. Номер соединения в этом случае не указывается, однако, если соединение между клиентами на сервере не установлено, этот пакет будет отброшен. Адресату доставляется OOB-ответ, в котором указан публичный ключ отправителя.


\section{Реализация TCP-клиента}

Для демонстрации алгоритмов работы протокола реализован клиент на Java, который позволяет подключиться к указанному bootstrap-узлу и установить соединение с таким же клиентом. Обмен данными между ними производится с помощью OOB-пакетов. 

Репозиторий с исходным кодом находится на Github: https://github.com/fresheed/tox-client.

\subsection{Интерфейс пользователя}

Программу запускает класс ControlConsole. В параметрах командной строки ему передаётся путь до конфигурационного файла c примерным содержанием:
\begin{verbatim}
CLIENT_PRIV_KEY=a590f856c785b225035fbe0ace13810fc2047dd02debc87ad4e6d17403967e5e

SERVER_PUB_KEY=53737F6D47FA6BD2808F378E339AF45BF86F39B64E79D6D491C53A1D522E7039
SERVER_HOST=d4rk4.ru
SERVER_PORT=1813
\end{verbatim}

Данный класс создаёт объекты, обозначающие локальный и удалённый узлы, создаёт соединение между ними, а затем в цикле считывает пользовательский ввод и выполняет требуемые операции:

\begin{itemize}
\item connect PUBLIC\_KEY - отправляет серверу запрос на соединение с указанным узлом. В ответном выводе указывается номер соединения
\item oob CONNECTION\_ID MESSAGE - отправляет по указанному соединению сообщение
\item quit - выход
\end{itemize}

\subsection{Работа с TCP}

Использование конкретного канала данных (в данном случае - TCP) скрыто за интерфейсом DataChannel с основными методами send и receive. При чтении контролируется число считываемых байт. 

Также TCP-сервер представлен подклассом RemotePeer, который обозначает абстрактный удалённый узел. RemotePeer предоставляет метод получения DataChannel, который в данном случае является TCP-соединением по соответствующему IP и порту.

\subsection{Криптография}

Для выполнения криптографических функций используется биндинг NaCl к Java - Kalium. 

Также используются вспомогательные классы, упрощающие получение nonce и шифрование-дешифрование сообщений между конкретными узлами.

\subsection{Узлы и соединения}

Узлы представляются интерфейсами LocalPeer и RemotePeer. Основное отличие - LocalPeer позволяет получить приватный ключ.

Класс ToxRelayedConnection инкапсулирует логику обмена сообщениями между узлами. Для инициации соединения используется статический метод connect, в котором производится обмен handshake-пакетами. Далее создаётся объект ToxRelayedConnection, в который передаются полученные временные ключи. Полученный объект используется для шифрования входящих и исходящих сообщений.


\subsection{Сообщения}

В настоящий момент реализованы следующие типы сообщений:
\begin{itemize}
\item ping
\item routing
\item connect/disconnect notifications
\item OOB
\item handshake
\end{itemize}

Для унификации интерфейса используются классы ToxIncomingMessage и ToxOutgoingMessage. Основной метод для первого - accept(), который позволяет обработать его. Для этого применяется паттерн Visitor: объект, обрабатывающий сообщение, вызывает на нём accept, передавая себя как аргумент, а объект-сообщение вызывает один из методов visitMessageType. Кроме того, объекты этого класса должны иметь конструктор, принимающий массив байт, чтобы сообщение можно было разобрать при получении. Для исходящего сообщения основным методом является getContent(), возвращающий набор байт для дальнейшей отправки. 

Также существуют классы ToxDataType, которые отражают заданные в спецификации типы данных. В настоящее время используются только числовые типы - 8,16,64-битные числа.


\section{Задание для студентов}

Необходимо реализовать алгоритм, описанный в разделе "Обмен данными между клиентами с использованием TCP-сервера":
\begin{enumerate}
\item разобраться с логикой отправки и обработки onion-пакетов и выбора TCP-серверов для установения соединения
\item подключившись к супер-нодам, осуществить отправку friend request произвольному узлу (использовать в качестве получателя запроса любой GUI-клиент)
\item реализовать отправку текстовых сообщений (тип MESSAGE) узлам-друзьям
\end{enumerate}

После решения этой задачи можно приступить к менее приоритетным:
\begin{itemize}
\item реализация других типов сообщений (как для передачи данных, так и статусных - например, "собеседник печатает")
\item повышение тестового покрытия
\item реализация GUI
\end{itemize}

\section{Ссылки на ресурсы}

\begin{itemize}
\item https://toktok.ltd/spec - спецификация протокола
\item https://github.com/TokTok/c-toxcore - ядро протокола, написанное на C
\item https://github.com/TokTok/qTox - один из популярных клиентов
\item https://wiki.tox.chat - Wiki проекта
\item https://habrahabr.ru/post/217289/ - описание последовательности действий для установления соединения
\item irc://irc.freenode.net/\#toktok, https://www.reddit.com/r/projecttox/ - сообщества пользователей и разработчиков Tox.

В частности, https://www.reddit.com/r/projecttox/comments/64e6xv - вопрос, заданный автором курсовой работы 2017 года по поводу алгоритма установления соединения
\item https://github.com/fresheed/tox-client - код Java-клиента
\end{itemize}

\end{document}